<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>kunkunboy</title>
    <link>https://www.kunkunboy.com/</link>
    
    <image>
      <url>https://www.kunkunboy.com/icon.png</url>
      <title>kunkunboy</title>
      <link>https://www.kunkunboy.com/</link>
    </image>
    
    <atom:link href="https://www.kunkunboy.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sat, 02 Jan 2021 10:21:26 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>iOS现代自动布局</title>
      <link>https://www.kunkunboy.com/archives/98e4e333.html</link>
      <guid>https://www.kunkunboy.com/archives/98e4e333.html</guid>
      <pubDate>Sun, 27 Dec 2020 00:27:31 GMT</pubDate>
      
      <description>&lt;p&gt;今年12月看完了一本关于iOS自动布局的作品，叫&lt;a href=&quot;https://useyourloaf.com/autolayout/&quot;&gt;Modern Auto Layout&lt;/a&gt;，作者是&lt;code&gt;Keith Harrison&lt;/code&gt;，知名博客&lt;a href=&quot;https://useyourloaf.com/&quot;&gt;Use Your Loaf&lt;/a&gt;的作者，一位元老级程序员。这本书里介绍了iOS自动布局的概念、发展、技术细节、API更新和使用场景，即使懂iOS但是自动布局方面零基础的开发者，只要坚持看完并且完成每章的课后练习，也能做到布局菜鸟变大师。这篇博客就简单做个总结性的笔记，提炼一些重点和自我理解。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>今年12月看完了一本关于iOS自动布局的作品，叫<a href="https://useyourloaf.com/autolayout/">Modern Auto Layout</a>，作者是<code>Keith Harrison</code>，知名博客<a href="https://useyourloaf.com/">Use Your Loaf</a>的作者，一位元老级程序员。这本书里介绍了iOS自动布局的概念、发展、技术细节、API更新和使用场景，即使懂iOS但是自动布局方面零基础的开发者，只要坚持看完并且完成每章的课后练习，也能做到布局菜鸟变大师。这篇博客就简单做个总结性的笔记，提炼一些重点和自我理解。</p><h2 id="弹簧与支柱"><a href="#弹簧与支柱" class="headerlink" title="弹簧与支柱"></a>弹簧与支柱</h2><p>在自动布局出现以前，我们都是通过设置view.frame来做到布局的，但是随着iPhone和iPad的迭代升级，出现不同大大小小的屏幕，导致手动布局的代码变得难以维护。为了做到视图自适应的效果，苹果最开始给出了弹簧与支柱<code>(springs and struts)</code>的解决方案，你可以在Interface Builder里看到这样的截图：<br><img src="/archives/98e4e333/springs_and_struts.JPG" alt="strings and struts"><br>它的意思就是：通过设置视图外在的上下左右四个<code>支柱</code>来固定与父视图的间距，以及设置内部的宽高<code>弹簧</code>来决定是否自适应宽高。这样的话，视图就会跟随父视图frame的变化而变化。换成代码的话，就叫做<code>Autoresizing Mask</code>。特别注意，用IB做和用代码做是不同的，代码中没有支柱的概念，比如设置固定上、左、右边距和自动宽度效果的话，用代码就得这么写：</p><pre><code>greenView.autoresizingMask = [.flexibleWidth, .flexibleBottomMargin]</code></pre><p>弹簧与支柱的方法，解决了父子视图之间自适应的问题，但是却无法解决兄弟视图的自适应。比如视图A有两个子视图B和C，可以用弹簧与支柱来确定A与B、A与C的自适应关系，但是B和C如果想要保持一个固定的间距，这种问题就超越了弹簧与支柱的能力，但是可以用自动布局实现。</p><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>自动布局的核心是约束<code>(NSLayoutConstraint)</code>，约束是指定视图之间的关系和规则，然后在运行时再将规则转换成视图的frame。而约束的本质其实是数学公式，比如指定两个视图之间的距离，其实就是创建一个约束公式：<br><img src="/archives/98e4e333/constraint_equation.JPG" alt="constraint equation"><br>约束可以设置的关系有很多，比如这些例子：</p><pre><code>// 垂直方向间距redView.top == greenView.bottom + 8.0// 宽高倍数redView.height == 0.5 x greenView.height// 不等关系redView.width &lt;= greenView.width// 长宽比greenView.height = 0.5 x greenView.width// 宽高常数redView.height = 50.0</code></pre><p>使用代码创建的话，苹果官方给了三种方式：</p><ul><li>使用NSLayoutConstraint类相关的API（公式版API，使用很麻烦，如果你只是写业务而不是写framework，就别用了）</li><li>使用Visual Format Language（创意很好，但是不能在编译时检查错误，可读性一般，几乎很少被采用）</li><li>使用NSLayoutAnchor（iOS9推出，支持不完全检查编译错误，官方推荐）</li></ul><p>作为长期写业务的程序员，我也知道很多人都在用知名的开源库（比如OC版的Masonry和Swift版的SnapKit），这些库的流行体现了它们链式语法的API使用简洁和可维护的特点，减少了我们的开发时间。作者并没有说不推荐使用开源库，而是强调使用之前首先需要了解自动布局的原理，而不是仅仅停留在只会用的层面。</p><h3 id="需要多少约束才足够？"><a href="#需要多少约束才足够？" class="headerlink" title="需要多少约束才足够？"></a>需要多少约束才足够？</h3><p>结论是需要满足以下原则，<strong>至少需要足够的约束来固定层级中每个视图的大小(size)和位置(position)，接着在维度上，size需要在水平和垂直方向各需要至少一个约束，position也是同样的。</strong></p><p>比如给一个view添加足够的约束，通常有两种方式：</p><ul><li>添加与父视图之间的top, left约束（确定了view的position）；还需要添加width, height约束（确定了view的size）。</li><li>添加与父视图之间的top, left约束（确定了view的position）；继续添加与父视图的bottom, right约束（这样相当于间接确定了view的size）。</li></ul><p>有时候简单执行上面的方法也是不够的，比如下面这个例子，按照截图中的规则添加约束。<br><img src="/archives/98e4e333/sibling_views_1.JPG" alt="sibling views 1"><br>当黄色视图水平拉伸的时候，依然无法确定红色和绿色两个视图的宽度该怎么分配，这就造成了歧义(ambiguity)。<br><img src="/archives/98e4e333/sibling_views_2.JPG" alt="sibling views 2"><br>如果再为它们添加一个等宽的约束，才能最终确定子视图的size，这才算是足够。</p><h3 id="约束被谁拥有呢？"><a href="#约束被谁拥有呢？" class="headerlink" title="约束被谁拥有呢？"></a>约束被谁拥有呢？</h3><p>约束创建出来，总需要有个地方保存（被持有）吧。UIView有个只读属性<code>constraints</code>，即拥有的约束集合，说明约束是被UIView对象所持有的。问题是，每一个创建出来的约束，究竟该分配给哪个视图呢。官方定义是，<strong>视图拥有的约束只能包含该视图本身或其子视图。</strong>举个例子就清楚了，比如有红绿黄三个视图，yellowView是另外两个的父视图，两个子视图有自己的宽高约束，greenView居中对齐，redView为水平居中且垂直距离greenView16个单位。<br><img src="/archives/98e4e333/constraint_owner_1.JPG" alt="constraint owner 1"><br>这个例子中，每个view的constraints究竟包含哪些约束呢？拿greenView来说，宽高约束都设给自己的，跟其他view没有关系，所以自己拥有它们；中心约束是相对父视图的，对于涉及了父视图的约束根据定义就只能由作为父视图的yellowView拥有；垂直方向16单位的约束所涉及同级的视图，谁拥有都不合适，所以依然是父视图yellowView拥有。<br><img src="/archives/98e4e333/constraint_owner_2.JPG" alt="constraint owner 2"></p><h2 id="Layout-Guide"><a href="#Layout-Guide" class="headerlink" title="Layout Guide"></a>Layout Guide</h2><p>自iOS9以后，苹果推出了<code>UILayoutGuide</code>，我把它简单理解为一个既看不见也不能响应事件交互的矩形框。它不是视图，也不会存在于视图层级中，而它可以参与自动布局中约束关系的创建，在布局中起到<code>占位视图</code>的作用。比如某些时候，你可能为了完成一些复杂的布局，需要创建几个不带背景色的UIView仅仅是为了放在那里填充位置，实现等宽等距或视图居中的效果，现在这些工作也可以交给layout guide来完成，因为正好符合它的特点（看不见且无视点击的矩形框）。</p><h3 id="Safe-Area"><a href="#Safe-Area" class="headerlink" title="Safe Area"></a>Safe Area</h3><p>但是layout guide只是用在这里就有些小题大做了，苹果在iOS11推出了<code>Safe Area</code>的概念，也就是视图安全区域，它的作用就是让视图不会被状态栏、导航栏、tab栏和刘海头给遮挡，可以通过UIView的<code>safeAreaLayoutGuide</code>属性获取。以下是Safe Area的示意图<br><img src="/archives/98e4e333/safe_area.JPG" alt="safe area"><br>为了兼容低版本的iOS，可以在代码中可以用<code>topLayoutGuide</code>和<code>bottomLayoutGuide</code>来适配类似的效果（后来推出了安全区域后就被苹果废弃了），但如果你使用IB来创建约束，即使使用了Safe Layout Guide，系统也会帮你自动兼容到iOS9的。</p><h3 id="Margins"><a href="#Margins" class="headerlink" title="Margins"></a>Margins</h3><p>如果在父子视图布局中需要额外边距(Margins)的话，可以使用UIView的<code>layoutMarginsGuide</code>来布局。边距大小也是可以通过UIView的<code>layoutMargins</code>来修改的，这些margins直到视图显示在屏幕上时才会被最终确定(viewDidAppear)。在iOS11，苹果还支持了<code>directionalLayoutMargins</code>来满足right-to-left语言的适配。</p><p>需要注意的是，对于iOS11以下的版本，开发者不能更改根视图的margins，意思是如果你尝试修改viewController.view.layoutMargins的话是无效的。而且margin guide会忽视掉top/bottomLayoutGuide，这样就导致基于margin guide的视图有可能被导航栏给遮住。</p><p>从个人的开发经历来说，我从来没有使用过它，一直是简单粗暴地创建间距约束在做需求，毕竟个人觉得设置约束的constant更加直观一些。</p><h3 id="Readable"><a href="#Readable" class="headerlink" title="Readable"></a>Readable</h3><p>假如你做了一个跟屏幕同宽的tableView列表，在手机上滑动看着正好，但是放在iPad用横屏一看，是不是会觉得列表太宽了，影响了视觉体验吧。苹果有一个<code>readableContentGuide</code>可以解决这个问题，在宽屏的iPad上，会给列表左右两边留出适当的空白，让整个内容的展示空间限制在中间的区域。实在无法脑补的话，建议在Mac上用Safari浏览器打开一篇文章，点击“显示阅读器”感受一下。这就是苹果为阅读模式提供的布局。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>写了这么多layout guide，对于支持iOS 11+的App来说：</p><ul><li>建议使用<code>safeAreaLayoutGuide</code></li><li>可以安全地使用<code>layoutMarginsGuide</code></li><li>如有right-to-left布局需要，可以使用<code>directionalLayoutMargins</code><br>对于iOS 9+，如有阅读布局需要，推荐使用<code>readableContentGuide</code>来避免内容在iPad上过于拉伸。</li></ul><h2 id="内容自适应"><a href="#内容自适应" class="headerlink" title="内容自适应"></a>内容自适应</h2><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>讲内容自适应之前，先要明确一个优先级(priority)的概念。给约束设置优先级是为了防止多个约束冲突，从而优先执行级别高的。优先级是1～1000范围内的数字，UIKit给优先级设置了三个档位：defaultLow(250), defaultHeight(750), required(1000)，无论是IB还是代码，通常情况下创建的约束都是最高优先级required(1000)。</p><p>我有时候因为需要而创建一些“备用”约束作为“额外的保护性措施”，避免视图在极端情况下不会出问题，但是又不想跟现有的约束发生冲突，那么可以把这种约束的低优先级设置相对低一些。这样布局引擎就会在运行时优先满足优先级最高(required)的约束，必要时尽可能满足优先级偏低的约束。</p><h3 id="自带内容宽高"><a href="#自带内容宽高" class="headerlink" title="自带内容宽高"></a>自带内容宽高</h3><p>有些特殊的UIView其实是自带内容的，比如UILabel有文字，UIImageView有图片，像这些视图，即使不去主动设置宽高约束，它们也可以根据自己的内容大小来决定应该在布局中如何正确展示宽高。这是怎么做到的呢？</p><p>每个UIView对象都有一个<code>intrinsicContentSize</code>的属性，如果视图在布局的时候没有宽高约束的话，布局引擎会根据它返回的CGSize给视图补上相应的宽高约束，UIImageView重载了这个方法，并且返回自身图片的大小，所以布局UIImageView的话，无论代码还是IB，在它设置了图片的情况下只需要添加UIImageView的水平和垂直位置约束就足够了。</p><p>这里提到了布局引擎根据内容而自动添加的宽高约束，可以理解成我前面提到的“备用”约束。如果你觉得图片本身的尺寸不合适，也可以主动添加宽高约束，因为人工主动添加的约束优先级默认都是最高的，因此布局引擎会优先满足它。</p><p>对于没有内容的视图，intrinsicContentSize返回的宽高都是-1，UIKit专门定义了一个<code>UIViewNoIntrinsicMetric</code>的常量，用来描述某一个（宽或高）维度中没有明确长度的情况。</p><p>这里摘录一些UIKit常用组件的intrinsicContentSize</p><ul><li>UILabel如果有text，注意当numberOfLines为1时，intrinsicContentSize.width就是文本单行的长度，text很长，label就很长，即使给label设置宽度约束，内容宽度依然很长。</li><li>设置UIButton的contentEdgeInsets会增加按钮的内容宽高，可以理解为把多添加的内间距变成“内容”的一部分，从而显得按钮视觉区域更大；但是设置titleEdgeInsets和imageEdgeInsets并不会增加内容宽高，因为后两个属性的设置是在布局结束后才生效的。</li><li>UISlider和UIProgressView都只有内容高度，没有宽度，所以为它们布局约束时设置好宽度就足够了。</li><li>UITextView在开启了scrollEnabled的情况下，没有内容宽高，而在滑动行为禁止的情况下就表现得像多行文本的UILabel一样，不过大多数情况下，还是建议主动为它添加宽高约束吧。</li></ul><p>对于自定义的UIView，如果希望使用内容自适应的特性，也同样可以重载这个方法来实现：</p><pre><code>class CustomView: UIView {    override var intrinsicContentSize: CGSize {        // 宽度无法自己决定，但是高度默认是100        return CGSize(width: UIViewNoIntrinsicMetric, height: 100)     }}</code></pre><h3 id="拒绝拉伸和压缩"><a href="#拒绝拉伸和压缩" class="headerlink" title="拒绝拉伸和压缩"></a>拒绝拉伸和压缩</h3><p>比如这个截图，有图片和文本，它们的size都是根据内容来自适应的，所以不需要人为设置宽度约束。但是问题在于，当屏幕变宽时，谁可以优先被拉伸？当屏幕变窄时，谁又可以优先被压缩呢？<br><img src="/archives/98e4e333/priority_1.JPG" alt="priority 1"><br>解决这个问题，需要引进两个概念：拒绝拉伸优先级<code>Content-Hugging priority</code>和拒绝压缩优先级<code>Compression-Resistance priority</code>，这样就好理解了。再看上面的例子，将图片的两个拒绝值都提高1个单位，当屏幕变宽时，由于图片相对于文本更加拒绝被拉伸，所以文本宽度就被拉伸开了；当屏幕变窄时，由于图片相对于文本更加拒绝被压缩，所以文本的宽度就被挤压而导致换行。<br><img src="/archives/98e4e333/priority_2.JPG" alt="priority 2"></p><h2 id="UIKit组合技"><a href="#UIKit组合技" class="headerlink" title="UIKit组合技"></a>UIKit组合技</h2><h3 id="UIStackView"><a href="#UIStackView" class="headerlink" title="UIStackView"></a>UIStackView</h3><p>苹果推出的<code>UIStackView</code>非常方便的满足了弹性布局(Flexbox)的需求，使用stack的方式布局，既减少了约束维护成本，而且它的强大之处在于通过嵌套布局完成复杂的UI，比如下面这个截图，只用UIStackView来布局完全足够了：<br><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Nested_Stack_Views_Screenshot_2x.png" alt="UIStackView"></p><p>对于UIStackView，我总结了几个基本点：</p><ul><li>首先需要指明<code>axis</code>，即stack方向是水平布局还是垂直布局</li><li>属性<code>distribution</code>表示在axis方向上的布局，细节就不写了，网上有很多<strong>带图</strong>的博客</li><li>属性<code>alignment</code>表示与axis相对方向的布局，比如axis是水平方向，那alignment就是垂直方向的布局</li><li>布局时，如果没有设置stackView的宽高约束，那么它会根据自己的arrangedSubviews来计算自己的size，如果设置了宽高约束，那么它会根据“拒绝拉伸/压缩优先级”来相应改变arrangedSubviews的size。</li><li>自iOS11以后，可以自定义的间距<code>setCustomSpacing</code></li><li>自iOS12以后，stackView的性能被苹果提升了一个档次，所以对于开发并不追求性能的界面，我肯定会选择节省时间的stackView</li></ul><h3 id="UIScrollView"><a href="#UIScrollView" class="headerlink" title="UIScrollView"></a>UIScrollView</h3><p>如何把用自动布局实现的UI，放在UIScrollView上滑动呢？这是个好问题。因为scrollView之所以能够滑动的条件是contentSize大于frame.size，但是自动布局是等到运行时才能计算出内容视图最终的size，那有没有可能在得到size之前先设置好约束规则，让scrollView的contentSize自动响应内容的size结果呢？方法如下：</p><ol><li>自定义一个<code>ContentView</code>作为承载所有内容视图的容器，然后设置层级为RootView -&gt; ScrollView -&gt; ContentView，添加好所有边界(Edges)约束</li><li>如果你只允许垂直滑动的话，就给scrollView和contentView添加等宽约束（禁止水平滑动）；如果你只允许水平滑动的话，就给它们添加等高约束（禁止垂直滑动）</li><li>将内容都添加到contentView中，设置好它们的边界约束</li></ol><p>另外如果UIStackView满足条件的话，可以直接用它来替代上面提到的contentView。作者介绍该技巧的时候，也附赠了相应的<a href="https://github.com/kharrison/albookcode/tree/main/sample-code/scroll-views/ScrollStack-v1">demo（点击查看）</a>。</p><h3 id="UITableView自适应cell"><a href="#UITableView自适应cell" class="headerlink" title="UITableView自适应cell"></a>UITableView自适应cell</h3><p>根据文本内容计算高度的列表cell这类的需求，自从iOS发展至今一直都存在。如何利用自动布局来完成自动计算cell的高度呢？这种“鸡生蛋，蛋生鸡”的问题，在iOS8以后就有了解决方案：</p><ol><li>把自定义的视图都放在UITableViewCell的<code>contentView</code>上并设置好约束</li><li>设置<code>tableView.rowHeight = UITableView.automaticDimension</code>来取消固定行高</li><li>设置<code>tableView.estimatedRowHeight = 任何大于等于零的值</code>来启动估算行高，这里指定一个预设值，而实际的行高会由自动布局来计算<br>详情也可以参考</li></ol><h2 id="布局引擎"><a href="#布局引擎" class="headerlink" title="布局引擎"></a>布局引擎</h2><p>布局引擎是用来处理约束的更新和计算frame的地方。当改变了约束的<code>active, constant, priority</code>，或者视图被移除层级的时候，会导致约束更新。但这种更新并不会立即改变view.frame，为了提高效率，布局引擎会把这些批量改动安排到一次传递(Layout Pass)中，等待下一次runloop到来时执行。当传递被执行的时候，会在视图层级中经历两次传递过程：</p><ol><li>第一次是约束更新的传递（也可以通过手动调用<code>setNeedsUpdateConstraints</code>触发）。在此过程中，系统遍历视图层级，调用<code>updateViewConstraints</code>和<code>updateConstraints</code>方法来更新约束。</li><li>第二次是更新视图frame（也可以通过手动调用<code>setNeedsLayout</code>触发）。在此过程中，系统遍历视图层级，调用<code>layoutSubviews</code>方法，通过引擎根据约束规则计算出frame并设置给每个视图的subviews</li></ol><h3 id="可以重载updateConstraints吗？"><a href="#可以重载updateConstraints吗？" class="headerlink" title="可以重载updateConstraints吗？"></a>可以重载updateConstraints吗？</h3><p>是可以的。比如Masonry有个<a href="https://github.com/snapkit/masonry#where-should-i-create-my-constraints">示例代码（点击查看）</a>，自定义一个视图，通过重载该方法实现更新约束，然后点击按钮时调用<code>setNeedsUpdateConstraints</code>来触发约束更新行为。虽说允许重载，不过苹果明确说明，若不是为了优化等特殊操作，不建议在这里创建约束。一般建立约束关系通常都是在viewDidLoad或者IB里面就可以。注意<strong>不要在重载方法里调用<code>setNeedsUpdateConstraints</code>，死循环！</strong></p><h3 id="可以重载layoutSubviews吗？"><a href="#可以重载layoutSubviews吗？" class="headerlink" title="可以重载layoutSubviews吗？"></a>可以重载layoutSubviews吗？</h3><p>当然可以，比如存在自动布局无法实现的布局，或者根本不使用自动布局的话，都可以通过重载该方法来直接修改子视图的frame。<strong>不要在重载方法里调用<code>setNeedsLayout</code>和<code>setNeedsUpdateConstraints</code>，死循环！</strong></p><h3 id="布局动画"><a href="#布局动画" class="headerlink" title="布局动画"></a>布局动画</h3><p>由于布局的更新不会立即生效，所以对于UIView动画而言，只有在动画的block里调用<code>layoutIfNeeded</code>方法，让布局立即生效，才能捕捉到视图的结束状态而顺利完成动画。该方法同样适用于iOS10推出的<code>UIViewPropertyAnimator</code>。</p><h3 id="Alignment-Rect"><a href="#Alignment-Rect" class="headerlink" title="Alignment Rect"></a>Alignment Rect</h3><p>在布局时，引擎是根据视图的<code>Alignment Rect</code>来确定其位置的，而不是frame。为什么会这样呢？比如有些特殊情况，当视图存在阴影、右上角的红点数(Badge)，或者这个带阴影的图片等<a href="https://github.com/kharrison/ALBookCode/tree/master/sample-code/engine/Alignment-v1/">demo示例</a>，而你希望在布局计算时考虑这些因素的话，就需要用到它了。UIView提供了<code>alignmentRectInsets</code>和<code>alignmentRect(forFrame:)</code>这些API以便修改。</p><h2 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h2><h3 id="AutoresizingMask冲突"><a href="#AutoresizingMask冲突" class="headerlink" title="AutoresizingMask冲突"></a>AutoresizingMask冲突</h3><p>最常见的问题，就是在Xcode控制台看到<code>Unable to simultaneously satisfy constraints</code>，然后出现<code>NSAutoresizingMaskLayoutConstraint</code>之类的信息。这种情况原因就是，通过代码创建的UIView时，系统会自动把它默认的autoresizing mask转换成自动布局约束，结果就跟你为视图添加的约束冲突了。所以写布局代码时，一定别忘了加上这句：</p><pre><code>view.translatesAutoresizingMaskIntoConstraints = false</code></pre><p>（好在<code>Masonry</code>和<code>SnapKit</code>这些开源库已经为我们做了这些琐事，真让人省心。）</p><h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><p>还有一个技巧就是，给视图和约束添加标记。设置约束的<code>identifier</code>和设置视图的<code>accessibilityIdentifier</code>，就可以在约束日志里看到对应的是哪个视图和哪个约束了，很方便。</p><h3 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h3><p>开发者可以通过调用<code>hasAmbiguousLayout</code>和<code>exerciseAmbiguityInLayout</code>方法检查视图是否存在约束不明确的bug，甚至可以在调试环境里调用<code>_autolayoutTrace</code>（私有API）来查看视图层级里是否存在Ambiguous Layout，但我基本上没有用过，因为读日志太累。相反，现在倒是有很多可视化工具可以在运行时检查视图层级的布局，相比代码检查方便多了，比如：</p><ul><li>Xcode自带的<code>Xcode View Debugger</code></li><li>强大的付费调试软件<a href="https://revealapp.com/">Reveal</a></li><li>腾讯开源的<a href="https://lookin.work/">Lookin</a></li></ul><h2 id="视图的生命周期"><a href="#视图的生命周期" class="headerlink" title="视图的生命周期"></a>视图的生命周期</h2><p>作者在介绍布局之前，也详细介绍了视图加载和生命周期相关的知识点，我总结一下。</p><h3 id="UIViewController如何加载自己的view"><a href="#UIViewController如何加载自己的view" class="headerlink" title="UIViewController如何加载自己的view"></a>UIViewController如何加载自己的view</h3><p>懒加载，通常是需要使用到view的时候，UIViewController会调用<code>loadView()</code>方法来加载UIView，loadView()方法会寻找是否存在nib或者storyboard文件并加载，如果没有就创建新的UIView对象。开发者不允许直接调用loadView()，如果需要强制加载view的话，可以调用<code>loadViewIfNeeded()</code>，而且可以通过<code>isViewLoaded</code>来判断view是否加载完成。</p><h3 id="loadView是如何寻找nib文件的？"><a href="#loadView是如何寻找nib文件的？" class="headerlink" title="loadView是如何寻找nib文件的？"></a>loadView是如何寻找nib文件的？</h3><p>它首先根据vc的nibName属性来作为文件名称去寻找，如果没有给名称的话，就去找与vc相同类名的文件。比如vc的类叫RootViewController，那么loadView就会依次查找RootView.nib和RootViewController.nib，如果有<code>RootViewController~ipad.nib</code>和<code>RootViewController~iphone.nib</code>这样的文件，那么loadView也会根据不同设备加载对应的文件。</p><h3 id="代码重载loadView"><a href="#代码重载loadView" class="headerlink" title="代码重载loadView"></a>代码重载loadView</h3><p>如果不用nib或者storyboard文件来加载view的话，也可以直接重载loadView方法。</p><pre><code>class RootViewController: UIViewController {     override func loadView() {        // 不要调super        let rootView = UIView()        rootView.backgroundColor = .yellow        view = rootView    }}</code></pre><h3 id="手动布局可以在viewDidLoad里实现吗？"><a href="#手动布局可以在viewDidLoad里实现吗？" class="headerlink" title="手动布局可以在viewDidLoad里实现吗？"></a>手动布局可以在viewDidLoad里实现吗？</h3><p>严格来说的话，是不可以的。我们首先了解一下这些方法在vc的调用时机：</p><ul><li><code>loadView</code>：当需要使用view的时候，如果为nil，vc会调用loadView（懒）加载一个view</li><li><code>viewDidLoad</code>：在view加载完成后且没有被加入视图层级时调用，该方法在vc的生命周期中只会调用一次</li><li><code>viewWillAppear</code>：在view即将要加入视图层级时调用，该方法在vc的生命周期中会被多次调用，与之相对应的方法是viewWillDisappear</li><li><code>viewDidAppear</code>：在view已经加入到视图层级且显示在屏幕上时调用，该方法在vc的生命周期中会被多次调用，与之相对应的方法是viewDidDisappear</li></ul><p>因为loadView, viewDidLoad和viewWillAppear调用的时候，vc的view并没有加入到视图层级中，所以view的size没有最终成型，所以手动布局中如果依赖view.bounds或frame不一定是最终的结果；而viewDidAppear已经显示到屏幕上了，此时手动布局时机又太晚。</p><p>合适时机在哪里呢？答案是<code>viewWillLayoutSubviews</code>和<code>viewDidLayoutSubviews</code>，因为这是vc的view即将和完成布局subviews的时机。但是这些方法会多次调用，需要注意。</p><h2 id="其他附加技能"><a href="#其他附加技能" class="headerlink" title="其他附加技能"></a>其他附加技能</h2><p>本书在谈论自动布局的过程中，也结合了其他UIKit的特性，比如：</p><ul><li>支持iOS的字体大小设置(Dynamic type)</li><li>支持多屏幕适配(UITraitCollection)</li><li>响应键盘高度的技巧</li></ul>]]></content:encoded>
      
      
      <category domain="https://www.kunkunboy.com/categories/code/">code</category>
      
      
      <category domain="https://www.kunkunboy.com/tags/Auto-Layout/">Auto Layout</category>
      
      <category domain="https://www.kunkunboy.com/tags/iOS/">iOS</category>
      
      
      <comments>https://www.kunkunboy.com/archives/98e4e333.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>个人静态博客搭建指南</title>
      <link>https://www.kunkunboy.com/archives/2d635022.html</link>
      <guid>https://www.kunkunboy.com/archives/2d635022.html</guid>
      <pubDate>Sat, 31 Oct 2020 11:15:09 GMT</pubDate>
      
      <description>&lt;p&gt;先聊聊为什么要写博客。像其他程序员一样，我以前也会通过写博客的方式记录自己的所学和总结，但是很遗憾，最终没有坚持。首先坚持不是一件容易的事情，尤其是写博客，不仅消耗精力和时间，而且分享的东西也不一定会有人看。我最近正在看《软技能：代码之外的生存指南》这本书，里面提到了为什么建议读者写博客的原因。总结说来就是，如果你想要真正学到东西，那么你需要学会分享。通过向他人讲述知识，不仅可以让你看到自己的盲区，而且也需要花时间组织知识信息和语言，写博客就是其中一种途径。你不需要成为行业专家才有资格去分享，只是把学到的东西，哪怕很小的概念能解释清楚就好。另外，如果总是抱着寻求关注的心态去写作，那么也很容易失望，毕竟获取关注的前提是，你能为别人提供什么价值，而且是免费的。如果不用为了刻意寻求关注而写博客，写写自己感兴趣的东西，同时相信自己写的东西对其他某些同样需要帮助的人来说也是有价值的，这样的话在心态上会轻松很多。 &lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>先聊聊为什么要写博客。像其他程序员一样，我以前也会通过写博客的方式记录自己的所学和总结，但是很遗憾，最终没有坚持。首先坚持不是一件容易的事情，尤其是写博客，不仅消耗精力和时间，而且分享的东西也不一定会有人看。我最近正在看《软技能：代码之外的生存指南》这本书，里面提到了为什么建议读者写博客的原因。总结说来就是，如果你想要真正学到东西，那么你需要学会分享。通过向他人讲述知识，不仅可以让你看到自己的盲区，而且也需要花时间组织知识信息和语言，写博客就是其中一种途径。你不需要成为行业专家才有资格去分享，只是把学到的东西，哪怕很小的概念能解释清楚就好。另外，如果总是抱着寻求关注的心态去写作，那么也很容易失望，毕竟获取关注的前提是，你能为别人提供什么价值，而且是免费的。如果不用为了刻意寻求关注而写博客，写写自己感兴趣的东西，同时相信自己写的东西对其他某些同样需要帮助的人来说也是有价值的，这样的话在心态上会轻松很多。 </p><blockquote><p>博客是很棒的地方，它能让你在教自己所学的知识的同时不必承受过多的压力。在你掌握一个主题之后，可以撰写博客来分享自己所学。看看自己能不能以这一简单的方式来从接受到的信息中提炼要点。 — John Z. Sonmez</p></blockquote><p>除了提炼学到的东西以外，我认为也可以通过写博客来观察自己的想法。比如阅读一本书的读后感，电影观后感等等。所以我没有打算写纯技术博客，我觉得技术以外的世界其实更有意思。另外，真心不推荐在晚上创作，除非你能接受睡前写博客带来的兴奋会影响入睡的问题。</p><p>下面就是搭建博客的技术部分了。我在这里记录一下自己搭建静态博客的方案和想法。如果你有git经验或者喜欢编程、DIY，想自己动手像做一个航模一样来创建博客却苦于没有思路和经验，或者因为选择太多而无法做决定的话，可以参考我提供的<code>Hexo+Github+自定义域名</code>组合<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。</p><h4 id="第三方服务vs-个人建站"><a href="#第三方服务vs-个人建站" class="headerlink" title="第三方服务vs.个人建站"></a>第三方服务vs.个人建站</h4><p>在2006年左右博客在国内还是挺火的，比如新浪博客、百度空间等等。当时我自己也开了账号，只是没有什么值得分享的内容。现在大众熟知的博客社区有简书，或者程序技术细分市场的CSDN、掘金等等。如果你想要开博客，可以选择一个知名的博客服务提供商，注册个账户，省去了自己建站的麻烦，而且也会有流量，有评论功能，这些都是选择第三方博客提供商的优势。但是选择第三方服务也有一些弊端，比如可能因为不赚钱、流量减少等原因导致服务下线关闭（比如百度空间）；或者比如展示你的博客时，突然冒出一个广告或推荐弹窗，影响阅读体验（比如新浪博客）；或者网页风格千篇一律，不足以表达你的自由和个性。</p><p>在如今微博和短视频风靡的当下，博客看似已经退居二线，但是依然有存在感，而且存在形式早就不是当初只有一两家很大的博客服务提供商来瓜分世界版图的格局了，现在每个人都有机会自己动手建立个人博客网站。自己建站的优势在于自由和独立，但是也会有额外的运营和维护工作，流量也只能靠搜索引擎和自主宣传。在平衡利弊以后，你可以选择第三方服务，也可以选择低成本搭建个人博客站点。</p><h4 id="静态博客生成器"><a href="#静态博客生成器" class="headerlink" title="静态博客生成器"></a>静态博客生成器</h4><p>首先介绍一种动态博客，比如<a href="https://cn.wordpress.org/">WordPress</a>，就是包含了数据库、后台管理系统和前端页面的网站。相反，另一种是静态博客，它不需要后台的管理，没有数据库，没有评论系统（当然也可以通过插件支持），不用运行服务器的框架程序，通过工具把Markdown格式的博客文章直接渲染成HTML静态网页展示给用户就行了，非常轻量<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。静态博客主要是文字内容的展示和发布，功能单一，但是搭建过程是一门技术活，适合有编程基础的极客博主。</p><p><a href="https://hexo.io/zh-cn/">Hexo</a>是一款轻量且高性能的静态博客生成工具，在官网上有详细的安装和配置教程，还有很多个性十足的<a href="https://hexo.io/themes/">主题样式</a>、插件可供选择。其实除了hexo，还有很多其他优秀的静态生成器，比如<a href="https://www.jekyll.com.cn/">Jekyll</a>（我因为没用过，所以就不做评论了）。我选用hexo而不是WordPress的原因主要是前者免费，而且以前也尝试用它写过博客，所以更熟悉一些，再加上静态博客精简和轻量的特点，可以不需要考虑后台的维护；相比之下，作为动态博客的WordPress也很强大，它甚至提供了包括域名绑定和后端搭建的一体化服务，让没有编程基础的用户也可以建立自己的网站或博客。选择WordPress的用户可能更想要做专业网站，比如创业或品牌宣传，在找不到程序员的条件下自己就能搞出来，不过等网站做大了，用户流量和关注也随之上涨，也就需要考虑升级和付费服务了。</p><p>hexo的安装细节就不写在这里了，<a href="https://hexo.io/zh-cn/">官网</a>和其他博客里都有手把手的详细教程。使用<code>hexo init</code>完成初始化以后，可以重点留意下面这几个目录。</p><pre><code>├── _config.yml # 博客配置项，比如标题、主题、部署位置├── package.json # hexo的程序信息├── public      # 生成最终的发布网页├── scaffolds   # 博客模版，可以自定义文章编辑样式├── source      # 原始资源，包括文章和其他内容，比如后面自定义域名用到的CNAME│&nbsp;&nbsp; └── _posts  # 博客文章，使用hexo new生成的文章都会放在这里└── themes      # 博客主题，每个主题目录下都会包含自己的_config.yml配置文件</code></pre><p>另外建议在博客根目录下使用git进行追踪管理（指定忽略public目录和db.json数据库），这样以后更改配置的话就方便保存了。如果使用多台pc/mac切换写博客的话，最好使用远程私有仓库来同步，因为配置文件里都会包含账号等敏感信息。（如果你换了电脑后，第一次同步完博客根目录的数据，使用hexo命令发现报错的话，需要重新在该目录下<code>npm install</code>来安装缺失的hexo组件）</p><p>常用的命令也就这几个，很好记：</p><pre><code>hexo new &lt;post&gt;     # 创建一篇新文章的markdown文件hexo g      # generate 生成博客网页和其他文件hexo s      # server 开启本地预览模式，在浏览器中输入localhost:4000即可看到效果，而且改动文章以后直接去浏览器刷新一下就出效果hexo d      # deploy 部署到托管服务器hexo clean  # 清除数据</code></pre><p>hexo的配置代码格式要求很严谨，可能因为少个空格或者文章tags格式不规范都会导致命令出错。遇到各种报错问题的时候，不要慌张，在日志里找到报错原因去网上搜索答案就行。这些问题基本都有前人栽过跟头，而且他们都热心的在网上分享了自己的解决方案。</p><h4 id="免费托管"><a href="#免费托管" class="headerlink" title="免费托管"></a>免费托管</h4><p>用hexo生成的静态博客站点，还需要找一个服务器进行托管才行，这里推荐<a href="https://pages.github.com/">Github Pages</a>服务，这是目前最大的git在线仓库托管服务商推出的免费网站托管服务，是静态博客的绝佳部署场景。当然也可以选择国内的<a href="https://gitee.com/">gitee</a>或者<a href="https://coding.net/">coding</a>的pages服务作为博客站点托管，而且托管在国内站点会让你的博客页面打开速度更快，<del>但是我认为（目前被微软收购的）github提供的pages服务会更加稳健和成熟一些，不太会出现费用门槛或服务停用的问题，但是如果因为国家之间政治问题导致github无法访问的话，那就另当别论了。</del>（更新）后来看了godxiaolong写的<a href="https://blog.csdn.net/weixin_45682081/article/details/104486787">Hexo 双线部署到 Coding 和 GitHub 提升访问速度</a>后，发现还是使用两个托管服务更加稳妥：境外一个，境内一个。如果只托管在github的话，会发现无法使用百度搜索，据说因为GitHub禁止了百度的爬取。</p><p>选择Github的话，首先需要创建一个Github Pages，简单的说就是：注册一个github账号，创建一个名为<code>&lt;username&gt;.github.io</code>的公开仓库<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>（这里和下文中的username需要换成你的实际用户名），在仓库根目录下添加一个<code>index.html</code>的文件，这样就能在浏览器中输入<code>https://username.github.io</code>访问到你的网站了（其实就是访问的index.html文件）。具体操作步骤可以在<a href="https://pages.github.com/">官网</a>上找到。</p><p>接下来就是将hexo的博客部署地址设为github，首先需要安装<a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>插件，然后在hexo博客根目录下的<code>_config.yml</code>文件中添加deploy配置。</p><pre><code>deploy:  type: git  repo:    github:      url: &lt;repository url&gt;      branch: [branch]    coding:      ...    gitee:      ... # 部署完gitee后，还要去pages服务页面手动刷新</code></pre><p>这里也可以同时添加其他多个git仓库，比如前面提到的gitee和coding的远程仓库。当hexo部署的时候，就可以同时部署到多个在线托管服务中了。比如在github上部署成功以后，你就可以在浏览器中访问<code>https://username.github.io</code>看到你的第一篇博客了。</p><h4 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h4><p>Github Pages服务也允许用户使用自定义域名（比如访问<code>www.example.com</code>）来代替默认的<code>&lt;username&gt;.github.io</code>，其实我也推荐设置自定义域名，因为如果有用户关注你的博客，肯定会记住你的名字，假如你哪天更换了托管服务，不再使用github的话，用户也能通过你的域名找到你的博客新家。这里涉及到如何从一个域名映射到另一个域名的问题，解决方法是同时在Github和域名提供商两端都配置好一个叫<code>CNAME</code>的东西，具体如何做呢？</p><ul><li>首先从域名提供商购买一个你中意的域名<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>，我使用的是<a href="https://wanwang.aliyun.com/">阿里云万网</a>，不仅价格合适，而且购买之后可以继续申请实名认证服务。</li><li>回到Github，选择你的博客仓库，点击<code>Settings</code>，在<code>Custom domain</code>这里填写你买下的域名，点击<code>Save</code>就可以了。这里需要提示一下：<ul><li>建议先在仓库的设置里配置完后，再去比如阿里云的域名服务那里设置解析，可能是Github出自安全考虑。</li><li>建议填写带有<code>www</code>或者<code>blog</code>的子域名，不建议直接填写顶级域名。比如你拥有的域名是<code>example.com</code>，那么你可以填写<code>www.example.com</code>。</li></ul></li><li>接下来回到阿里云，找到域名/云解析DNS/域名解析/解析设置，点击添加记录，添加一个<code>CNAME</code>类型的记录，将你的<code>www.example.com</code>（主机记录）指向<code>&lt;username&gt;.github.io</code>（记录值），这样用户在浏览器中输入<code>www.example.com</code>的时候，就可以映射到你在github上托管的博客页面了。配置完等待几分钟，用浏览器试一下效果。<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup><ul><li>如果用户在浏览器中输入<code>example.com</code>或者<code>blog.example.com</code>来定位你的博客怎么办？同样，可以再添加两个CNAME记录，主机记录分别是<code>@.example.com</code>和<code>blog.example.com</code>，它们指向的记录值都是<code>www.example.com</code>，这样不论用户输入其中哪个地址，都会映射到<code>www.example.com</code></li></ul></li><li>使用自定义域名的话，github是不会默认使用https环境的，而你需要做的也就是等几个小时，再回到Github的博客仓库，去设置里找到并勾选<code>Enforce HTTPS</code>的选项就行了，这样用户访问到的就是https环境下的博客地址。开启https的话，会给用户留下安全和靠谱的印象。给自定义的域名配置https环境是需要时间的，默认说要等24个小时，其实好像也没那么久，当然等上一天以后再勾选肯定是没问题的。</li></ul><p>由于填写的是子域名，点击Save后，Github会自动在仓库的根目录下生成一个<code>CNAME</code>文件，这样隐晦的行为你可能真的不会留意。<strong>但是需要特别注意</strong>，当你用<code>hexo deploy</code>进行部署时会把仓库里的文件都替换掉的，包括这个CNAME文件。所以<strong>解决方法是在hexo博客的source目录下的保存一份CNAME</strong>，这样每次部署都会带上CNAME文件。简单的步骤就是，检查一下你在github上生成的CNAME文件内容，比如就<code>www.example.com</code>一行文本，然后通过命令行定位到hexo博客根目录下，输入以下命令即可。</p><pre><code>echo "www.example.com" &gt;&gt; source/CNAME</code></pre><p>如果上面总结的不够细致，建议直接阅读Github Pages的<a href="https://docs.github.com/en/free-pro-team@latest/github/working-with-github-pages/about-custom-domains-and-github-pages">自定义域名说明</a>和<a href="https://docs.github.com/en/free-pro-team@latest/github/working-with-github-pages/managing-a-custom-domain-for-your-github-pages-site">操作方法</a>。关于阿里云的域名解析，可以在添加记录的时候，点击<code>?</code>查看帮助。</p><p><strong>更新补充：</strong>对于同时托管到境内和境外的服务器的话，在完成上面的解析后，可以继续添加<code>CNAME</code>到境内的站点，比如同样开启了gitee pages服务的话，就将<code>www.example.com</code>（主机记录）指向<code>&lt;username&gt;.gitee.io</code>（记录值），解析线路选择为默认。你也可以把之前指向github记录的线路改成境外，但是阿里云是智能解析，所以用默认就可以了。于是用户从境外访问<code>www.example.com</code>就会指向github服务器，而境内用户就指向到gitee，从而加快页面打开速度。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>配置好一个博客还有很多其他的细节需要考虑：比如文章署名，是否需要<a href="https://zhuanlan.zhihu.com/p/92241815">评论</a>、访问统计等等，这些一般都是通过插件或者修改代码来完成，而且不同的主题下的配置方式也有所不同，比如hexo安装的默认主题是<code>landscape</code>，那么可以在网上找到这款主题的<a href="https://github.com/hexojs/hexo-theme-landscape">Github源代码</a>，然后在介绍页里寻找答案，至于其他的主题也可以采用这种方式来找到解决方案。我在搭建自己博客的时候，也会参考和借鉴其他优秀的博客给出的实现方案，尤其是图文并茂的引导步骤，非常受益。如果你也像我一样，一开始只通过三方博客去寻求问题的解决方案而毫无进展的话，还是建议花些时间寻找和研读一下官方或开源作者提供的文档和帮助，因为这些看似枯燥的长篇大论，其实可能蕴含了很多你正在寻求解决问题的本质。</p><p>祝顺利。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">特别说明，我使用的是macOS环境。</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">Markdown是一种通用的文本格式，你无需考虑排版细节，只需要关注内容即可。</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">Github规定免费用户的公开仓库，或者高级付费用户的私有仓库可以创建Pages服务。</span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;">由于实在想不到什么好名字，于是就模仿电影名jojo rabbit找了一个<code>kunkunboy.com</code>的域名。</span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;">也可以通过在命令行输入<code>dig www.example.com +nostats +nocomments +nocmd</code>可以查看域名解析结果。</span><a href="#fnref:5" rev="footnote"> ↩</a></li></ol></div></div>]]></content:encoded>
      
      
      <category domain="https://www.kunkunboy.com/categories/code/">code</category>
      
      
      <category domain="https://www.kunkunboy.com/tags/hexo/">hexo</category>
      
      <category domain="https://www.kunkunboy.com/tags/blog/">blog</category>
      
      
      <comments>https://www.kunkunboy.com/archives/2d635022.html#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
