<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <!-- 谷歌统计 -->
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'G-PWN2XBP76D', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  <!-- 百度统计 -->
  <!-- 百度统计 -->

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?547b5983788aec3fe6d8dcfbab9df299";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

  
  <title>iOS现代自动布局 | kunkunboy</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="今年12月看完了一本关于iOS自动布局的作品，叫Modern Auto Layout，作者是Keith Harrison，知名博客Use Your Loaf的作者，一位元老级程序员。这本书里介绍了iOS自动布局的概念、发展、技术细节、API更新和使用场景，即使懂iOS但是自动布局方面零基础的开发者，只要坚持看完并且完成每章的课后练习，也能做到布局菜鸟变大师。这篇博客就简单做个总结性的笔记，提炼一些">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS现代自动布局">
<meta property="og:url" content="https://www.kunkunboy.com/archives/98e4e333.html">
<meta property="og:site_name" content="kunkunboy">
<meta property="og:description" content="今年12月看完了一本关于iOS自动布局的作品，叫Modern Auto Layout，作者是Keith Harrison，知名博客Use Your Loaf的作者，一位元老级程序员。这本书里介绍了iOS自动布局的概念、发展、技术细节、API更新和使用场景，即使懂iOS但是自动布局方面零基础的开发者，只要坚持看完并且完成每章的课后练习，也能做到布局菜鸟变大师。这篇博客就简单做个总结性的笔记，提炼一些">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.kunkunboy.com/archives/98e4e333/springs_and_struts.JPG">
<meta property="og:image" content="https://www.kunkunboy.com/archives/98e4e333/constraint_equation.JPG">
<meta property="og:image" content="https://www.kunkunboy.com/archives/98e4e333/sibling_views_1.JPG">
<meta property="og:image" content="https://www.kunkunboy.com/archives/98e4e333/sibling_views_2.JPG">
<meta property="og:image" content="https://www.kunkunboy.com/archives/98e4e333/constraint_owner_1.JPG">
<meta property="og:image" content="https://www.kunkunboy.com/archives/98e4e333/constraint_owner_2.JPG">
<meta property="og:image" content="https://www.kunkunboy.com/archives/98e4e333/safe_area.JPG">
<meta property="og:image" content="https://www.kunkunboy.com/archives/98e4e333/priority_1.JPG">
<meta property="og:image" content="https://www.kunkunboy.com/archives/98e4e333/priority_2.JPG">
<meta property="og:image" content="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Nested_Stack_Views_Screenshot_2x.png">
<meta property="article:published_time" content="2020-12-27T00:27:31.000Z">
<meta property="article:modified_time" content="2021-01-01T05:05:38.070Z">
<meta property="article:author" content="kunkunboy">
<meta property="article:tag" content="Auto Layout">
<meta property="article:tag" content="iOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.kunkunboy.com/archives/98e4e333/springs_and_struts.JPG">
  
    <link rel="alternate" href="/atom.xml" title="kunkunboy" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">


  <!-- 百度自动推送 -->
  
  <script>
      (function(){
          var bp = document.createElement('script');
          var curProtocol = window.location.protocol.split(':')[0];
          if (curProtocol === 'https') {
              bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
          }
          else {
              bp.src = 'http://push.zhanzhang.baidu.com/push.js';
          }
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(bp, s);
      })();
  </script>
   

<meta name="generator" content="Hexo 5.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">kunkunboy</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://www.kunkunboy.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-modern-auto-layout" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/98e4e333.html" class="article-date">
  <time datetime="2020-12-27T00:27:31.000Z" itemprop="datePublished">2020-12-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/code/">code</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      iOS现代自动布局
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今年12月看完了一本关于iOS自动布局的作品，叫<a target="_blank" rel="noopener external nofollow noreferrer" href="https://useyourloaf.com/autolayout/">Modern Auto Layout</a>，作者是<code>Keith Harrison</code>，知名博客<a target="_blank" rel="noopener external nofollow noreferrer" href="https://useyourloaf.com/">Use Your Loaf</a>的作者，一位元老级程序员。这本书里介绍了iOS自动布局的概念、发展、技术细节、API更新和使用场景，即使懂iOS但是自动布局方面零基础的开发者，只要坚持看完并且完成每章的课后练习，也能做到布局菜鸟变大师。这篇博客就简单做个总结性的笔记，提炼一些重点和自我理解。</p>
<h2 id="弹簧与支柱"><a href="#弹簧与支柱" class="headerlink" title="弹簧与支柱"></a>弹簧与支柱</h2><p>在自动布局出现以前，我们都是通过设置view.frame来做到布局的，但是随着iPhone和iPad的迭代升级，出现不同大大小小的屏幕，导致手动布局的代码变得难以维护。为了做到视图自适应的效果，苹果最开始给出了弹簧与支柱<code>(springs and struts)</code>的解决方案，你可以在Interface Builder里看到这样的截图：<br><img src="/archives/98e4e333/springs_and_struts.JPG" alt="strings and struts"><br>它的意思就是：通过设置视图外在的上下左右四个<code>支柱</code>来固定与父视图的间距，以及设置内部的宽高<code>弹簧</code>来决定是否自适应宽高。这样的话，视图就会跟随父视图frame的变化而变化。换成代码的话，就叫做<code>Autoresizing Mask</code>。特别注意，用IB做和用代码做是不同的，代码中没有支柱的概念，比如设置固定上、左、右边距和自动宽度效果的话，用代码就得这么写：</p>
<pre><code>greenView.autoresizingMask = [.flexibleWidth, .flexibleBottomMargin]</code></pre>
<p>弹簧与支柱的方法，解决了父子视图之间自适应的问题，但是却无法解决兄弟视图的自适应。比如视图A有两个子视图B和C，可以用弹簧与支柱来确定A与B、A与C的自适应关系，但是B和C如果想要保持一个固定的间距，这种问题就超越了弹簧与支柱的能力，但是可以用自动布局实现。</p>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>自动布局的核心是约束<code>(NSLayoutConstraint)</code>，约束是指定视图之间的关系和规则，然后在运行时再将规则转换成视图的frame。而约束的本质其实是数学公式，比如指定两个视图之间的距离，其实就是创建一个约束公式：<br><img src="/archives/98e4e333/constraint_equation.JPG" alt="constraint equation"><br>约束可以设置的关系有很多，比如这些例子：</p>
<pre><code>// 垂直方向间距
redView.top == greenView.bottom + 8.0
// 宽高倍数
redView.height == 0.5 x greenView.height
// 不等关系
redView.width &lt;= greenView.width
// 长宽比
greenView.height = 0.5 x greenView.width
// 宽高常数
redView.height = 50.0</code></pre>
<p>使用代码创建的话，苹果官方给了三种方式：</p>
<ul>
<li>使用NSLayoutConstraint类相关的API（公式版API，使用很麻烦，如果你只是写业务而不是写framework，就别用了）</li>
<li>使用Visual Format Language（创意很好，但是不能在编译时检查错误，可读性一般，几乎很少被采用）</li>
<li>使用NSLayoutAnchor（iOS9推出，支持不完全检查编译错误，官方推荐）</li>
</ul>
<p>作为长期写业务的程序员，我也知道很多人都在用知名的开源库（比如OC版的Masonry和Swift版的SnapKit），这些库的流行体现了它们链式语法的API使用简洁和可维护的特点，减少了我们的开发时间。作者并没有说不推荐使用开源库，而是强调使用之前首先需要了解自动布局的原理，而不是仅仅停留在只会用的层面。</p>
<h4 id="需要多少约束才足够？"><a href="#需要多少约束才足够？" class="headerlink" title="需要多少约束才足够？"></a>需要多少约束才足够？</h4><p>结论是需要满足以下原则，<strong>至少需要足够的约束来固定层级中每个视图的大小(size)和位置(position)，接着在维度上，size需要在水平和垂直方向各需要至少一个约束，position也是同样的。</strong></p>
<p>比如给一个view添加足够的约束，通常有两种方式：</p>
<ul>
<li>添加与父视图之间的top, left约束（确定了view的position）；还需要添加width, height约束（确定了view的size）。</li>
<li>添加与父视图之间的top, left约束（确定了view的position）；继续添加与父视图的bottom, right约束（这样相当于间接确定了view的size）。</li>
</ul>
<p>有时候简单执行上面的方法也是不够的，比如下面这个例子，按照截图中的规则添加约束。<br><img src="/archives/98e4e333/sibling_views_1.JPG" alt="sibling views 1"><br>当黄色视图水平拉伸的时候，依然无法确定红色和绿色两个视图的宽度该怎么分配，这就造成了歧义(ambiguity)。<br><img src="/archives/98e4e333/sibling_views_2.JPG" alt="sibling views 2"><br>如果再为它们添加一个等宽的约束，才能最终确定子视图的size，这才算是足够。</p>
<h4 id="约束被谁拥有呢？"><a href="#约束被谁拥有呢？" class="headerlink" title="约束被谁拥有呢？"></a>约束被谁拥有呢？</h4><p>约束创建出来，总需要有个地方保存（被持有）吧。UIView有个只读属性<code>constraints</code>，即拥有的约束集合，说明约束是被UIView对象所持有的。问题是，每一个创建出来的约束，究竟该分配给哪个视图呢。官方定义是，<strong>视图拥有的约束只能包含该视图本身或其子视图。</strong>举个例子就清楚了，比如有红绿黄三个视图，yellowView是另外两个的父视图，两个子视图有自己的宽高约束，greenView居中对齐，redView为水平居中且垂直距离greenView16个单位。<br><img src="/archives/98e4e333/constraint_owner_1.JPG" alt="constraint owner 1"><br>这个例子中，每个view的constraints究竟包含哪些约束呢？拿greenView来说，宽高约束都设给自己的，跟其他view没有关系，所以自己拥有它们；中心约束是相对父视图的，对于涉及了父视图的约束根据定义就只能由作为父视图的yellowView拥有；垂直方向16单位的约束所涉及同级的视图，谁拥有都不合适，所以依然是父视图yellowView拥有。<br><img src="/archives/98e4e333/constraint_owner_2.JPG" alt="constraint owner 2"></p>
<h2 id="Layout-Guide"><a href="#Layout-Guide" class="headerlink" title="Layout Guide"></a>Layout Guide</h2><p>自iOS9以后，苹果推出了<code>UILayoutGuide</code>，我把它简单理解为一个既看不见也不能响应事件交互的矩形框。它不是视图，也不会存在于视图层级中，而它可以参与自动布局中约束关系的创建，在布局中起到<code>占位视图</code>的作用。比如某些时候，你可能为了完成一些复杂的布局，需要创建几个不带背景色的UIView仅仅是为了放在那里填充位置，实现等宽等距或视图居中的效果，现在这些工作也可以交给layout guide来完成，因为正好符合它的特点（看不见且无视点击的矩形框）。</p>
<h4 id="Safe-Area"><a href="#Safe-Area" class="headerlink" title="Safe Area"></a>Safe Area</h4><p>但是layout guide只是用在这里就有些小题大做了，苹果在iOS11推出了<code>Safe Area</code>的概念，也就是视图安全区域，它的作用就是让视图不会被状态栏、导航栏、tab栏和刘海头给遮挡，可以通过UIView的<code>safeAreaLayoutGuide</code>属性获取。以下是Safe Area的示意图<br><img src="/archives/98e4e333/safe_area.JPG" alt="safe area"><br>为了兼容低版本的iOS，可以在代码中可以用<code>topLayoutGuide</code>和<code>bottomLayoutGuide</code>来适配类似的效果（后来推出了安全区域后就被苹果废弃了），但如果你使用IB来创建约束，即使使用了Safe Layout Guide，系统也会帮你自动兼容到iOS9的。</p>
<h4 id="Margins"><a href="#Margins" class="headerlink" title="Margins"></a>Margins</h4><p>如果在父子视图布局中需要额外边距(Margins)的话，可以使用UIView的<code>layoutMarginsGuide</code>来布局。边距大小也是可以通过UIView的<code>layoutMargins</code>来修改的，这些margins直到视图显示在屏幕上时才会被最终确定(viewDidAppear)。在iOS11，苹果还支持了<code>directionalLayoutMargins</code>来满足right-to-left语言的适配。</p>
<p>需要注意的是，对于iOS11以下的版本，开发者不能更改根视图的margins，意思是如果你尝试修改viewController.view.layoutMargins的话是无效的。而且margin guide会忽视掉top/bottomLayoutGuide，这样就导致基于margin guide的视图有可能被导航栏给遮住。</p>
<p>从个人的开发经历来说，我从来没有使用过它，一直是简单粗暴地创建间距约束在做需求，毕竟个人觉得设置约束的constant更加直观一些。</p>
<h4 id="Readable"><a href="#Readable" class="headerlink" title="Readable"></a>Readable</h4><p>假如你做了一个跟屏幕同宽的tableView列表，在手机上滑动看着正好，但是放在iPad用横屏一看，是不是会觉得列表太宽了，影响了视觉体验吧。苹果有一个<code>readableContentGuide</code>可以解决这个问题，在宽屏的iPad上，会给列表左右两边留出适当的空白，让整个内容的展示空间限制在中间的区域。实在无法脑补的话，建议在Mac上用Safari浏览器打开一篇文章，点击“显示阅读器”感受一下。这就是苹果为阅读模式提供的布局。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>写了这么多layout guide，对于支持iOS 11+的App来说：</p>
<ul>
<li>建议使用<code>safeAreaLayoutGuide</code></li>
<li>可以安全地使用<code>layoutMarginsGuide</code></li>
<li>如有right-to-left布局需要，可以使用<code>directionalLayoutMargins</code><br>对于iOS 9+，如有阅读布局需要，推荐使用<code>readableContentGuide</code>来避免内容在iPad上过于拉伸。</li>
</ul>
<h2 id="内容自适应"><a href="#内容自适应" class="headerlink" title="内容自适应"></a>内容自适应</h2><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>讲内容自适应之前，先要明确一个优先级(priority)的概念。给约束设置优先级是为了防止多个约束冲突，从而优先执行级别高的。优先级是1～1000范围内的数字，UIKit给优先级设置了三个档位：defaultLow(250), defaultHeight(750), required(1000)，无论是IB还是代码，通常情况下创建的约束都是最高优先级required(1000)。</p>
<p>我有时候因为需要而创建一些“备用”约束作为“额外的保护性措施”，避免视图在极端情况下不会出问题，但是又不想跟现有的约束发生冲突，那么可以把这种约束的低优先级设置相对低一些。这样布局引擎就会在运行时优先满足优先级最高(required)的约束，必要时尽可能满足优先级偏低的约束。</p>
<h4 id="自带内容宽高"><a href="#自带内容宽高" class="headerlink" title="自带内容宽高"></a>自带内容宽高</h4><p>有些特殊的UIView其实是自带内容的，比如UILabel有文字，UIImageView有图片，像这些视图，即使不去主动设置宽高约束，它们也可以根据自己的内容大小来决定应该在布局中如何正确展示宽高。这是怎么做到的呢？</p>
<p>每个UIView对象都有一个<code>intrinsicContentSize</code>的属性，如果视图在布局的时候没有宽高约束的话，布局引擎会根据它返回的CGSize给视图补上相应的宽高约束，UIImageView重载了这个方法，并且返回自身图片的大小，所以布局UIImageView的话，无论代码还是IB，在它设置了图片的情况下只需要添加UIImageView的水平和垂直位置约束就足够了。</p>
<p>这里提到了布局引擎根据内容而自动添加的宽高约束，可以理解成我前面提到的“备用”约束。如果你觉得图片本身的尺寸不合适，也可以主动添加宽高约束，因为人工主动添加的约束优先级默认都是最高的，因此布局引擎会优先满足它。</p>
<p>对于没有内容的视图，intrinsicContentSize返回的宽高都是-1，UIKit专门定义了一个<code>UIViewNoIntrinsicMetric</code>的常量，用来描述某一个（宽或高）维度中没有明确长度的情况。</p>
<p>这里摘录一些UIKit常用组件的intrinsicContentSize</p>
<ul>
<li>UILabel如果有text，注意当numberOfLines为1时，intrinsicContentSize.width就是文本单行的长度，text很长，label就很长，即使给label设置宽度约束，内容宽度依然很长。</li>
<li>设置UIButton的contentEdgeInsets会增加按钮的内容宽高，可以理解为把多添加的内间距变成“内容”的一部分，从而显得按钮视觉区域更大；但是设置titleEdgeInsets和imageEdgeInsets并不会增加内容宽高，因为后两个属性的设置是在布局结束后才生效的。</li>
<li>UISlider和UIProgressView都只有内容高度，没有宽度，所以为它们布局约束时设置好宽度就足够了。</li>
<li>UITextView在开启了scrollEnabled的情况下，没有内容宽高，而在滑动行为禁止的情况下就表现得像多行文本的UILabel一样，不过大多数情况下，还是建议主动为它添加宽高约束吧。</li>
</ul>
<p>对于自定义的UIView，如果希望使用内容自适应的特性，也同样可以重载这个方法来实现：</p>
<pre><code>class CustomView: UIView {
    override var intrinsicContentSize: CGSize {
        // 宽度无法自己决定，但是高度默认是100
        return CGSize(width: UIViewNoIntrinsicMetric, height: 100) 
    }
}</code></pre>
<h4 id="拒绝拉伸和压缩"><a href="#拒绝拉伸和压缩" class="headerlink" title="拒绝拉伸和压缩"></a>拒绝拉伸和压缩</h4><p>比如这个截图，有图片和文本，它们的size都是根据内容来自适应的，所以不需要人为设置宽度约束。但是问题在于，当屏幕变宽时，谁可以优先被拉伸？当屏幕变窄时，谁又可以优先被压缩呢？<br><img src="/archives/98e4e333/priority_1.JPG" alt="priority 1"><br>解决这个问题，需要引进两个概念：拒绝拉伸优先级<code>Content-Hugging priority</code>和拒绝压缩优先级<code>Compression-Resistance priority</code>，这样就好理解了。再看上面的例子，将图片的两个拒绝值都提高1个单位，当屏幕变宽时，由于图片相对于文本更加拒绝被拉伸，所以文本宽度就被拉伸开了；当屏幕变窄时，由于图片相对于文本更加拒绝被压缩，所以文本的宽度就被挤压而导致换行。<br><img src="/archives/98e4e333/priority_2.JPG" alt="priority 2"></p>
<h2 id="UIKit组合技"><a href="#UIKit组合技" class="headerlink" title="UIKit组合技"></a>UIKit组合技</h2><h4 id="UIStackView"><a href="#UIStackView" class="headerlink" title="UIStackView"></a>UIStackView</h4><p>苹果推出的<code>UIStackView</code>非常方便的满足了弹性布局(Flexbox)的需求，使用stack的方式布局，既减少了约束维护成本，而且它的强大之处在于通过嵌套布局完成复杂的UI，比如下面这个截图，只用UIStackView来布局完全足够了：<br><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Nested_Stack_Views_Screenshot_2x.png" alt="UIStackView"></p>
<p>对于UIStackView，我总结了几个基本点：</p>
<ul>
<li>首先需要指明<code>axis</code>，即stack方向是水平布局还是垂直布局</li>
<li>属性<code>distribution</code>表示在axis方向上的布局，细节就不写了，网上有很多<strong>带图</strong>的博客</li>
<li>属性<code>alignment</code>表示与axis相对方向的布局，比如axis是水平方向，那alignment就是垂直方向的布局</li>
<li>布局时，如果没有设置stackView的宽高约束，那么它会根据自己的arrangedSubviews来计算自己的size，如果设置了宽高约束，那么它会根据“拒绝拉伸/压缩优先级”来相应改变arrangedSubviews的size。</li>
<li>自iOS11以后，可以自定义的间距<code>setCustomSpacing</code></li>
<li>自iOS12以后，stackView的性能被苹果提升了一个档次，所以对于开发并不追求性能的界面，我肯定会选择节省时间的stackView</li>
</ul>
<h4 id="UIScrollView"><a href="#UIScrollView" class="headerlink" title="UIScrollView"></a>UIScrollView</h4><p>如何把用自动布局实现的UI，放在UIScrollView上滑动呢？这是个好问题。因为scrollView之所以能够滑动的条件是contentSize大于frame.size，但是自动布局是等到运行时才能计算出内容视图最终的size，那有没有可能在得到size之前先设置好约束规则，让scrollView的contentSize自动响应内容的size结果呢？方法如下：</p>
<ol>
<li>自定义一个<code>ContentView</code>作为承载所有内容视图的容器，然后设置层级为RootView -&gt; ScrollView -&gt; ContentView，添加好所有边界(Edges)约束</li>
<li>如果你只允许垂直滑动的话，就给scrollView和contentView添加等宽约束（禁止水平滑动）；如果你只允许水平滑动的话，就给它们添加等高约束（禁止垂直滑动）</li>
<li>将内容都添加到contentView中，设置好它们的边界约束</li>
</ol>
<p>另外如果UIStackView满足条件的话，可以直接用它来替代上面提到的contentView。作者介绍该技巧的时候，也附赠了相应的<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/kharrison/albookcode/tree/main/sample-code/scroll-views/ScrollStack-v1">demo（点击查看）</a>。</p>
<h4 id="UITableView自适应cell"><a href="#UITableView自适应cell" class="headerlink" title="UITableView自适应cell"></a>UITableView自适应cell</h4><p>根据文本内容计算高度的列表cell这类的需求，自从iOS发展至今一直都存在。如何利用自动布局来完成自动计算cell的高度呢？这种“鸡生蛋，蛋生鸡”的问题，在iOS8以后就有了解决方案：</p>
<ol>
<li>把自定义的视图都放在UITableViewCell的<code>contentView</code>上并设置好约束</li>
<li>设置<code>tableView.rowHeight = UITableView.automaticDimension</code>来取消固定行高</li>
<li>设置<code>tableView.estimatedRowHeight = 任何大于等于零的值</code>来启动估算行高，这里指定一个预设值，而实际的行高会由自动布局来计算<br>详情也可以参考</li>
</ol>
<h2 id="布局引擎"><a href="#布局引擎" class="headerlink" title="布局引擎"></a>布局引擎</h2><p>布局引擎是用来处理约束的更新和计算frame的地方。当改变了约束的<code>active, constant, priority</code>，或者视图被移除层级的时候，会导致约束更新。但这种更新并不会立即改变view.frame，为了提高效率，布局引擎会把这些批量改动安排到一次传递(Layout Pass)中，等待下一次runloop到来时执行。当传递被执行的时候，会在视图层级中经历两次传递过程：</p>
<ol>
<li>第一次是约束更新的传递（也可以通过手动调用<code>setNeedsUpdateConstraints</code>触发）。在此过程中，系统遍历视图层级，调用<code>updateViewConstraints</code>和<code>updateConstraints</code>方法来更新约束。</li>
<li>第二次是更新视图frame（也可以通过手动调用<code>setNeedsLayout</code>触发）。在此过程中，系统遍历视图层级，调用<code>layoutSubviews</code>方法，通过引擎根据约束规则计算出frame并设置给每个视图的subviews</li>
</ol>
<h4 id="可以重载updateConstraints吗？"><a href="#可以重载updateConstraints吗？" class="headerlink" title="可以重载updateConstraints吗？"></a>可以重载updateConstraints吗？</h4><p>是可以的。比如Masonry有个<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/snapkit/masonry#where-should-i-create-my-constraints">示例代码（点击查看）</a>，自定义一个视图，通过重载该方法实现更新约束，然后点击按钮时调用<code>setNeedsUpdateConstraints</code>来触发约束更新行为。虽说允许重载，不过苹果明确说明，若不是为了优化等特殊操作，不建议在这里创建约束。一般建立约束关系通常都是在viewDidLoad或者IB里面就可以。注意<strong>不要在重载方法里调用<code>setNeedsUpdateConstraints</code>，死循环！</strong></p>
<h4 id="可以重载layoutSubviews吗？"><a href="#可以重载layoutSubviews吗？" class="headerlink" title="可以重载layoutSubviews吗？"></a>可以重载layoutSubviews吗？</h4><p>当然可以，比如存在自动布局无法实现的布局，或者根本不使用自动布局的话，都可以通过重载该方法来直接修改子视图的frame。<strong>不要在重载方法里调用<code>setNeedsLayout</code>和<code>setNeedsUpdateConstraints</code>，死循环！</strong></p>
<h4 id="布局动画"><a href="#布局动画" class="headerlink" title="布局动画"></a>布局动画</h4><p>由于布局的更新不会立即生效，所以对于UIView动画而言，只有在动画的block里调用<code>layoutIfNeeded</code>方法，让布局立即生效，才能捕捉到视图的结束状态而顺利完成动画。该方法同样适用于iOS10推出的<code>UIViewPropertyAnimator</code>。</p>
<h4 id="Alignment-Rect"><a href="#Alignment-Rect" class="headerlink" title="Alignment Rect"></a>Alignment Rect</h4><p>在布局时，引擎是根据视图的<code>Alignment Rect</code>来确定其位置的，而不是frame。为什么会这样呢？比如有些特殊情况，当视图存在阴影、右上角的红点数(Badge)，或者这个带阴影的图片等<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/kharrison/ALBookCode/tree/master/sample-code/engine/Alignment-v1/">demo示例</a>，而你希望在布局计算时考虑这些因素的话，就需要用到它了。UIView提供了<code>alignmentRectInsets</code>和<code>alignmentRect(forFrame:)</code>这些API以便修改。</p>
<h2 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h2><h4 id="AutoresizingMask冲突"><a href="#AutoresizingMask冲突" class="headerlink" title="AutoresizingMask冲突"></a>AutoresizingMask冲突</h4><p>最常见的问题，就是在Xcode控制台看到<code>Unable to simultaneously satisfy constraints</code>，然后出现<code>NSAutoresizingMaskLayoutConstraint</code>之类的信息。这种情况原因就是，通过代码创建的UIView时，系统会自动把它默认的autoresizing mask转换成自动布局约束，结果就跟你为视图添加的约束冲突了。所以写布局代码时，一定别忘了加上这句：</p>
<pre><code>view.translatesAutoresizingMaskIntoConstraints = false</code></pre>
<p>（好在<code>Masonry</code>和<code>SnapKit</code>这些开源库已经为我们做了这些琐事，真让人省心。）</p>
<h4 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h4><p>还有一个技巧就是，给视图和约束添加标记。设置约束的<code>identifier</code>和设置视图的<code>accessibilityIdentifier</code>，就可以在约束日志里看到对应的是哪个视图和哪个约束了，很方便。</p>
<h4 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h4><p>开发者可以通过调用<code>hasAmbiguousLayout</code>和<code>exerciseAmbiguityInLayout</code>方法检查视图是否存在约束不明确的bug，甚至可以在调试环境里调用<code>_autolayoutTrace</code>（私有API）来查看视图层级里是否存在Ambiguous Layout，但我基本上没有用过，因为读日志太累。相反，现在倒是有很多可视化工具可以在运行时检查视图层级的布局，相比代码检查方便多了，比如：</p>
<ul>
<li>Xcode自带的<code>Xcode View Debugger</code></li>
<li>强大的付费调试软件<a target="_blank" rel="noopener external nofollow noreferrer" href="https://revealapp.com/">Reveal</a></li>
<li>腾讯开源的<a target="_blank" rel="noopener external nofollow noreferrer" href="https://lookin.work/">Lookin</a></li>
</ul>
<h2 id="视图的生命周期"><a href="#视图的生命周期" class="headerlink" title="视图的生命周期"></a>视图的生命周期</h2><p>作者在介绍布局之前，也详细介绍了视图加载和生命周期相关的知识点，我总结一下。</p>
<h4 id="UIViewController如何加载自己的view"><a href="#UIViewController如何加载自己的view" class="headerlink" title="UIViewController如何加载自己的view"></a>UIViewController如何加载自己的view</h4><p>懒加载，通常是需要使用到view的时候，UIViewController会调用<code>loadView()</code>方法来加载UIView，loadView()方法会寻找是否存在nib或者storyboard文件并加载，如果没有就创建新的UIView对象。开发者不允许直接调用loadView()，如果需要强制加载view的话，可以调用<code>loadViewIfNeeded()</code>，而且可以通过<code>isViewLoaded</code>来判断view是否加载完成。</p>
<h4 id="loadView是如何寻找nib文件的？"><a href="#loadView是如何寻找nib文件的？" class="headerlink" title="loadView是如何寻找nib文件的？"></a>loadView是如何寻找nib文件的？</h4><p>它首先根据vc的nibName属性来作为文件名称去寻找，如果没有给名称的话，就去找与vc相同类名的文件。比如vc的类叫RootViewController，那么loadView就会依次查找RootView.nib和RootViewController.nib，如果有<code>RootViewController~ipad.nib</code>和<code>RootViewController~iphone.nib</code>这样的文件，那么loadView也会根据不同设备加载对应的文件。</p>
<h4 id="代码重载loadView"><a href="#代码重载loadView" class="headerlink" title="代码重载loadView"></a>代码重载loadView</h4><p>如果不用nib或者storyboard文件来加载view的话，也可以直接重载loadView方法。</p>
<pre><code>class RootViewController: UIViewController { 
    override func loadView() {
        // 不要调super
        let rootView = UIView()
        rootView.backgroundColor = .yellow
        view = rootView
    }
}</code></pre>
<h4 id="手动布局可以在viewDidLoad或者viewWillAppear里实现吗？"><a href="#手动布局可以在viewDidLoad或者viewWillAppear里实现吗？" class="headerlink" title="手动布局可以在viewDidLoad或者viewWillAppear里实现吗？"></a>手动布局可以在viewDidLoad或者viewWillAppear里实现吗？</h4><p>严格来说的话，是不可以的。我们首先了解一下这些方法在vc的调用时机：</p>
<ul>
<li><code>loadView</code>：当需要使用view的时候，如果为nil，vc会调用loadView（懒）加载一个view</li>
<li><code>viewDidLoad</code>：在view加载完成后且没有被加入视图层级时调用，该方法在vc的生命周期中只会调用一次</li>
<li><code>viewWillAppear</code>：在view即将要加入视图层级时调用，该方法在vc的生命周期中会被多次调用，与之相对应的方法是viewWillDisappear</li>
<li><code>viewDidAppear</code>：在view已经加入到视图层级且显示在屏幕上时调用，该方法在vc的生命周期中会被多次调用，与之相对应的方法是viewDidDisappear</li>
</ul>
<p>因为loadView, viewDidLoad和viewWillAppear调用的时候，vc的view并没有加入到视图层级中，所以view的size没有最终成型，所以手动布局中如果依赖view.bounds或frame不一定是最终的结果；而viewDidAppear已经显示到屏幕上了，此时手动布局时机又太晚。</p>
<p>合适时机在哪里呢？答案是<code>viewWillLayoutSubviews</code>和<code>viewDidLayoutSubviews</code>，因为这是vc的view即将和完成布局subviews的时机。但是这些方法会多次调用，需要注意。</p>
<h2 id="其他附加技能"><a href="#其他附加技能" class="headerlink" title="其他附加技能"></a>其他附加技能</h2><p>本书在谈论自动布局的过程中，也结合了其他UIKit的特性，比如：</p>
<ul>
<li>支持iOS的字体大小设置(Dynamic type)</li>
<li>支持多屏幕适配(UITraitCollection)</li>
<li>响应键盘高度的技巧</li>
</ul>

      
    </div>
    <!-- Copyright -->
    
      <div>
  <ul class="post-copyright">
    <li class="post-copyright-author">
    <strong>作者:  </strong>kunkunboy</a>
    </li>
    <li class="post-copyright-link">
    <strong>文章链接:  </strong>
    <a href="/archives/98e4e333.html" target="_blank" title="iOS现代自动布局">https://www.kunkunboy.com/archives/98e4e333.html</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明:   </strong>
      本博客所有文章除特别声明外，均采用<a rel="license external nofollow noreferrer" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
      许可协议。转载请注明出处！
    </li>
  </ul>
<div>
    
    <footer class="article-footer">
      <a data-url="https://www.kunkunboy.com/archives/98e4e333.html" data-id="ckjdt89nk0005e3e0ge5v0gb7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Auto-Layout/" rel="tag">Auto Layout</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li></ul>

    </footer>
  </div>
  
  
    
<nav id="article-nav">
  
  
    <a href="/archives/2d635022.html" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">个人静态博客搭建指南</div>
    </a>
  
</nav>

  
</article>




    <section id="comments" class="comments">
      <style>
        .comments{margin:30px;padding:10px;background:#fff}
        @media screen and (max-width:800px){.comments{margin:auto;padding:10px;background:#fff}}
      </style>
      <div class="valine_comment"></div>
<!--载入js，在</body>之前插入即可-->
<!--Leancloud 操作库:-->
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<!--Valine 的核心代码库-->
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
  new Valine({
      el: '.valine_comment',
      app_id: 'mJv3KUkAMy0oghu4bppULCar-gzGzoHsz',
      app_key: 'LuwRlpuq8cs8CONzMuHW1gvU',
      placeholder: '你有什么想法？',
      notify: 'true',
      verify: 'true',
    });
</script>
    </section>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/code/">code</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Auto-Layout/" rel="tag">Auto Layout</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blog/" rel="tag">blog</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/" rel="tag">iOS</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Auto-Layout/" style="font-size: 10px;">Auto Layout</a> <a href="/tags/blog/" style="font-size: 10px;">blog</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/iOS/" style="font-size: 10px;">iOS</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/archives/98e4e333.html">iOS现代自动布局</a>
          </li>
        
          <li>
            <a href="/archives/2d635022.html">个人静态博客搭建指南</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 kunkunboy<br>
      Powered by <a href="http://hexo.io/" rel="external nofollow noreferrer" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>